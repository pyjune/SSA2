def mv(cnt, d):  # n 주사위 정보, i d번 말의 위치
    i = B[pos[d]] if pos[d] in B else A[pos[d]]
    while cnt > 1:  # 주사위 숫자만큼 이동
        cnt -= 1
        i = A[i]

    return i

def f(n, s):  # 주사위 값, 지나간 칸의 합
    global maxV
    if n == 10:
        if maxV < s:
            maxV = s
    else:  # 남은 횟수가 있으면
        for k in range(4):  # 4개의 말을 각각 움직여 봄
            if pos[k] != 21:  # 도착이 아니면
                pre = pos[k]  # 원래 위치 저장
                e = mv(dice[n], k)  # 이동한 칸
                if e==21 or (e!=21 and e not in pos):
                    pos[k] = e
                    f(n + 1, s + C[e])
                pos[k] = pre


# A 연속 진행시 이동할 다음 자리, 연속이 아닌 경우만 딕셔너리로 변경 가능
A = [1, 2, 3, 4, 5, 6,  # 0~5
     7, 8, 9, 10, 11,  # 6-10
     12, 13, 14, 15, 16,  # 11-15
     17, 18, 19, 20, 21,  # 16-20
     21, 23, 24, 30, 26,  # 21-25
     30, 28, 29, 30, 31,  # 26-30
     32, 20]  # 31-32
# B 파란색 위치에서 이동하는 경우
B = {5:22, 10:25, 15:27}
# 각 칸의 점수
C = [0, 2, 4, 6, 8, 10,  # 0~5
     12, 14, 16, 18, 20,  # 6-10
     22, 24, 26, 28, 30,  # 11-15
     32, 34, 36, 38, 40,  # 16-20
     0, 13, 16, 19, 22,  # 21-25
     24, 28, 27, 26, 25,  # 26-30
     30, 35]

dice = list(map(int, input().split()))  # 5면 주사위 정보
pos = [0] * 4  # 각 말의 위치
maxV = 0
f(0, 0)  # 출발지
print(maxV)
